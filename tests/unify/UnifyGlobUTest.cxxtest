/**
 * tests/unify/UnifyGlobUTest.cxxtest
 *
 * Copyright (C) 2019 OpenCog Foundation
 * All Rights Reserved
 * Author: Kasim Ebrahim
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License v3 as
 * published by the Free Software Foundation and including the exceptions
 * at http://opencog.org/wiki/Licenses
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program; if not, write to:
 * Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <opencog/util/Logger.h>

#include <opencog/atoms/core/Context.h>
#include <opencog/unify/Unify.h>
#include <opencog/atomspace/AtomSpace.h>
#include <opencog/guile/SchemeEval.h>

#include <cxxtest/TestSuite.h>

using namespace opencog;

#define al _as.add_link
#define an _as.add_node

class UnifyGlobUTest :  public CxxTest::TestSuite
{
private:
	AtomSpace _as;
	SchemeEval _eval;
	// Note: GlobNodes are in uppercase and
	// variables are in lower case.
	Handle X, Y, x, A, B, AB;
	Context::VariablesStack X_varstack;

public:
	UnifyGlobUTest() : _eval(&_as)
	{
		logger().set_level(Logger::DEBUG);
		logger().set_print_to_stdout_flag(true);
		logger().set_timestamp_flag(false);

		X = an(GLOB_NODE, "$X");
		Y = an(GLOB_NODE, "$Y");

		x = an(VARIABLE_NODE, "$x");

		A = an(CONCEPT_NODE, "A");
		B = an(CONCEPT_NODE, "B");

		AB = al(LIST_LINK, A, B);
	}

	void setUp();

	void test_type_intersection_1();
	void test_type_intersection_2();
	void test_type_intersection_3();
	void test_type_intersection_4();
	void test_type_intersection_5();

	void test_unify_basic_1();
	void test_unify_basic_2();
	void test_unify_basic_3();
	void test_unify_basic_4();
	void test_unify_basic_5();
};

void UnifyGlobUTest::setUp(void)
{
}

void UnifyGlobUTest::test_type_intersection_1()
{
	Handle lhs = X;
	Handle rhs = x;
	Unify unify(lhs, rhs);
	Unify::CHandle result = unify.type_intersection(lhs, rhs),
			expected = rhs;

	TS_ASSERT_EQUALS(result, expected)
}

void UnifyGlobUTest::test_type_intersection_2()
{
	Handle lhs = X;
	Handle rhs = Y;

	Handle l_decl = al(TYPED_VARIABLE_LINK,
	                   X,
	                   al(TYPE_SET_LINK,
	                      al(INTERVAL_LINK,
	                         an(NUMBER_NODE, "1"),
	                         an(NUMBER_NODE, "4")),
	                      an(TYPE_NODE, "PredicateNode")));

	Handle r_decl = al(TYPED_VARIABLE_LINK,
	                   Y,
	                   al(TYPE_SET_LINK,
	                      al(INTERVAL_LINK,
	                         an(NUMBER_NODE, "2"),
	                         an(NUMBER_NODE, "3")),
	                      an(TYPE_NODE, "PredicateNode")));

	Unify unify(lhs, rhs, l_decl, r_decl);
	Unify::CHandle result = unify.type_intersection(lhs, rhs),
			expected = rhs;

	TS_ASSERT_EQUALS(result, expected)
}

void UnifyGlobUTest::test_type_intersection_3()
{
	Handle lhs = X;
	Handle rhs = AB;

	Handle l_decl = al(VARIABLE_LIST,
	                   al(TYPED_VARIABLE_LINK,
	                      X,
	                      al(TYPE_SET_LINK,
	                         al(INTERVAL_LINK,
	                            an(NUMBER_NODE, "1"),
	                            an(NUMBER_NODE, "2")),
	                         an(TYPE_NODE, "ConceptNode"))));

	Unify unify(lhs, rhs, l_decl);
	Unify::CHandle result = unify.type_intersection(lhs, rhs),
			expected = rhs;

	TS_ASSERT_EQUALS(result, expected)
}

void UnifyGlobUTest::test_type_intersection_4()
{
	Handle lhs = X;
	Handle rhs = AB;

	Handle l_decl = al(VARIABLE_LIST,
	                   al(TYPED_VARIABLE_LINK,
	                      X,
	                      al(TYPE_SET_LINK,
	                         al(INTERVAL_LINK,
	                            an(NUMBER_NODE, "1"),
	                            an(NUMBER_NODE, "1")),
	                         an(TYPE_NODE, "ConceptNode"))));

	Unify unify(lhs, rhs, l_decl);
	Unify::CHandle result = unify.type_intersection(lhs, rhs),
			expected = Unify::CHandle(Handle::UNDEFINED);

	TS_ASSERT_EQUALS(result, expected)
}

void UnifyGlobUTest::test_type_intersection_5()
{
	Handle lhs = X;
	Handle rhs = AB;

	Handle l_decl = al(VARIABLE_LIST,
	                   al(TYPED_VARIABLE_LINK,
	                      X,
	                      al(TYPE_SET_LINK,
	                         al(INTERVAL_LINK,
	                            an(NUMBER_NODE, "1"),
	                            an(NUMBER_NODE, "2")),
	                         an(TYPE_NODE, "ListLink"))));

	Unify unify(lhs, rhs, l_decl);
	Unify::CHandle result = unify.type_intersection(lhs, rhs),
			expected = rhs;

	TS_ASSERT_EQUALS(result, expected)
}

void UnifyGlobUTest::test_unify_basic_1()
{
	Unify unify(X, A);
	Unify::SolutionSet result = unify();
	Unify::SolutionSet expected =
			Unify::SolutionSet({{{{X, A}, A}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected)
}

void UnifyGlobUTest::test_unify_basic_2()
{
	Unify unify(X, Y);
	Unify::SolutionSet result = unify();

	// Note: The second element in a TypedBlock contains the most
	// specialized term. Yet at this instance neither[X nor Y] is more
	// specialized than the other.
	// The most specialized term is used to designate the type, meaning
	// for variables 'X' and 'Y' {{X, Y}, Y} and {{X, Y}, X} are considered
	// the same and wont be considered as two partitions of a solutionset.
	Unify::SolutionSet expected_1 =
			Unify::SolutionSet({{{{X, Y}, Y}}});
	Unify::SolutionSet expected_2 =
			Unify::SolutionSet({{{{X, Y}, X}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected_1 = " << oc_to_string(expected_1) << std::endl;
	std::cout << "expected_2 = " << oc_to_string(expected_2) << std::endl;

	TS_ASSERT((result==expected_1) or (result==expected_2))
}

void UnifyGlobUTest::test_unify_basic_3()
{
	Unify unify(X, x);
	Unify::SolutionSet result = unify();

	// Note: For two type undeclared Glob 'X' and Variable 'x', the
	// variable x is considered more specialized than the GlobNode.
	Unify::SolutionSet expected =
			Unify::SolutionSet({{{{X, x}, x}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected)
}

void UnifyGlobUTest::test_unify_basic_4()
{
	Unify unify(x, X);
	Unify::SolutionSet result = unify();

	// Note: For two type undeclared Glob 'X' and Variable 'x', the
	// variable x is considered more specialized than the GlobNode.
	Unify::SolutionSet expected =
			Unify::SolutionSet({{{{X, x}, x}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected)
}

void UnifyGlobUTest::test_unify_basic_5()
{
	Unify unify(X, AB);
	Unify::SolutionSet result = unify();

	Unify::SolutionSet expected =
			Unify::SolutionSet({{{{X, al(LIST_LINK, A, B)}, al(LIST_LINK, A, B)}}});

	std::cout << "result = " << oc_to_string(result) << std::endl;
	std::cout << "expected = " << oc_to_string(expected) << std::endl;

	TS_ASSERT_EQUALS(result, expected)
}

#undef al
#undef an
